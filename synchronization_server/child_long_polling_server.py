from gevent import monkey; monkey.patch_all() #declare BEFORE all imports
from base_non_blocking_server import *
from bottle import run

@route('/stream')
def stream():
	#secret = request.query.secret
	
	client_latest_clip_hash = request.query.latest_clip_hash #latest one on request
	
	server_latest_clip_row = get_latest_clip_row()
	
	#print "last: %s latest: %s"%(last_clip_id,latest_clip)
	
	while client_latest_clip_hash == server_latest_clip_row["sig"]:
		sleep(0.25) #wait a second
		server_latest_clip_row = get_latest_clip_row() #new query
	
	yield json.dumps(server_latest_clip_row)
	
@route('/new_clip', method='POST') #@post('/new_clip')
def post_new_clip():
	try:
		new_clip_content = str(request.forms.get("new_clip_content"))
		new_clip_sig = hex(mmh3.hash(new_clip_content))
		new_clip_id = str(clips.insert(dict(content=new_clip_content, sig = new_clip_sig) ) )
		status = dict(
			new_clip_sig = new_clip_sig,
			new_clip_id = new_clip_id,
			success = True,
			#new_clip_content = new_clip_content #temp
		)
	except:
		status = dict(
			success = False, 
			reason = str(sys.exc_info()[0]) #http://goo.gl/cmtlsL
		)
	yield json.dumps(status)

run(host='0.0.0.0', port=8083, server='gevent')


#LongPoll Client
"""
# Thread class that executes processing
class LongPollerThread(WorkerThread):

	def __init__(self, notify_window):
		#self.webSocketReconnect() #because threads have been "geventified" they no longer run in parallel, but rather asynchronously. So if this runs not within a greenlet, it will block the mainloop... gevent.sleep(1) only yields to another greenlet or couroutine (like wx.Yield) when it is called from within a greenlet.
		
		WorkerThread.__init__(self, notify_window)

	#initializes SERVER_LATEST_SIG.get()
	def outgoing(self):
		
		while self.KEEP_RUNNING:
			if CLIENT_LATEST_SIG.get() and SERVER_LATEST_SIG.get() != CLIENT_LATEST_SIG.get(): #DO NOT DO ANYTHING UNTIL HOST_CLIP_CONTENT.get() SET
				payload = dict(new_clip_content = HOST_CLIP_CONTENT.get())
				result = self.getResult(uri=HTTP_BASE("/new_clip"), payload=dict(new_clip_content = HOST_CLIP_CONTENT.get()) )
				if result and result['success'] == True:
					SERVER_LATEST_SIG.set(result['new_clip_sig'])
					CLIENT_LATEST_SIG.set(result['new_clip_sig'])
					print "Post: Host's Latest = %s"%SERVER_LATEST_SIG.get()
					wx.PostEvent(self._notify_window, EVT_RESULT(HOST_CLIP_CONTENT.get()) ) ##no need to set clipboard because it's already set!
			time.sleep(0.25)
		
		wx.PostEvent(self._notify_window, EVT_RESULT(None))
		

# Thread class that executes processing
	def incoming(self):

		while self.KEEP_RUNNING: #no point in polling if app just started
			if SERVER_LATEST_SIG.get(): #OLD: MUST CHECK, THIS IS VERY IMPORTANT AS ON STARTUP, THE UPDATER THREAD WILL POST AND CREATE A NEW ID, DURING WHEN POLLER WILL HAVE NONE FOR AN ID AND SET SERVER_LATEST_SIG.get() WRONG, COULD LEAD TO UNEXPECTED RACE
				print "\nLong-polling %s...\n"%SERVER_LATEST_SIG.get()
				result = self.getResult(uri=HTTP_BASE("/stream?latest_clip_hash=%s"%SERVER_LATEST_SIG.get() ) )
				if result and result['sig'] != SERVER_LATEST_SIG.get(): #just in case you just updated, leave clipboard alone #todo try except in result method
					print "LongPoll: Server's result = %s, Host's latest = %s"%(result['sig'], SERVER_LATEST_SIG.get())
					SERVER_LATEST_SIG.set(result['sig'])
					CLIENT_LATEST_SIG.set(result['sig']) #SERVER_LATEST_SIG.get() = CLIENT_LATEST_SIG.get() or else updater-thread will update if another device updates, and result in double mongodb entries #OLD- must use str as _id is an IdObject, generated by bson
					latest_content = result['content']
					wx.PostEvent(self._notify_window, EVT_RESULT(latest_content) )
				else:
					print "didn't work %s | %s"%(result['sig'] if result else "failed result", SERVER_LATEST_SIG.get())
			time.sleep(.25)
		
		wx.PostEvent(self._notify_window, EVT_RESULT(None))
		
	@staticmethod #no need for self or classmethod's cls
	def getResult(uri, payload=None):
		result = resp = None
		try:
			if payload:
				resp = requests.post(uri, data=payload)
			else:
				resp = requests.get(uri)
		except ConnectionError:
			print "You are disconnected" #todo - send error message to gui
		if resp and resp.status_code == requests.codes.ok:
			result = json.loads(resp.content)
		return result
		
	def getClipboardContent(self):
		return HOST_CLIP_CONTENT.get()
		
	def run(self):
		greenlets = [
			gevent.spawn(self.outgoing),
			gevent.spawn(self.incoming),
		]
		gevent.joinall(greenlets)
"""